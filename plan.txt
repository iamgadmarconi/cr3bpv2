Refactoring Plan: Polynomial with Numba Acceleration
Objective: Replace the SymEngine-based Polynomial class with Dictionary based Polynomial, using dict[tuple[int, ...], np.complex128] for storage and Numba for accelerating critical computations (multiplication, Poisson brackets).
Phase 1: Implement Polynomial Core (New Module: dict_core.py)
Class Definition:
Create dict_core.py.
Define DictPolynomial class.
Attributes:
variables: List[se.Symbol] (Keep original SymEngine symbols for mapping).
coeffs: Dict[Tuple[int, ...], np.complex128] (Maps exponent tuple to coefficient).
n_vars: int, n_dof: int.
_var_to_index: Dict[se.Symbol, int] (For quick lookup).
Coefficient Type: Use np.complex128 consistently for Numba compatibility and precision.
Initialization (__init__):
Store variables, calculate n_vars, n_dof, build _var_to_index.
Store input coeffs, filtering out any terms with coefficients close to zero (e.g., abs(coeff) < 1e-16).
Basic Methods & Properties (No Numba Yet):
__len__(self): Return len(self.coeffs).
__str__, __repr__: Implement a readable representation (can use to_symengine internally initially).
copy(self): Return a new instance with a copy of coeffs.
zero(cls, variables): Class method to create a zero polynomial.
from_coeffs(cls, variables, coeffs): Class method constructor.
total_degree(self): Iterate self.coeffs.keys(), return max(sum(key)). Handle empty dict (return 0 or -1).
truncate(self, max_deg): Create new DictPolynomial keeping only terms where sum(key) <= max_deg.
get_homogeneous_part(self, degree): Create new DictPolynomial keeping only terms where sum(key) == degree.
iter_terms(self): Yield (key, value) from self.coeffs.items().
Arithmetic (No Numba Yet):
__add__, __sub__: Iterate keys of self and other. Use defaultdict(np.complex128) to build result, filter near-zeros at the end. Check for matching variables.
__neg__: Multiply coefficients by -1.
__mul__(self, other):
Handle scalar multiplication (NumPy scalar or complex).
For DictPolynomial * DictPolynomial: Implement the standard nested loop algorithm. Aggregate results in defaultdict(np.complex128). Filter near-zeros. This will be the first target for Numba.
__pow__(self, exponent: int): Implement via repeated multiplication.
Differentiation & Poisson Bracket (No Numba Yet):
derivative(self, var_index: int): Iterate self.coeffs. Calculate new_key and new_coeff (coeff * key[var_index]). Aggregate in defaultdict. Return new DictPolynomial.
gradient(self): Call derivative for each var_index. Return List[DictPolynomial].
poisson(self, other): Implement sum_i (dF/dqi * dG/dpi - dF/dpi * dG/dqi) using the gradient, __mul__, __add__, __sub__ methods defined above. This will be functionally correct but slow.
Conversion Utilities:
to_symengine(self) -> se.Basic: Convert back to a SymEngine expression. Iterate self.coeffs, reconstruct term coeff * var1**k1 * var2**k2 ..., sum terms.
from_symengine(cls, variables: list[se.Symbol], expr: se.Basic) -> 'DictPolynomial':
Crucial: First, clean the input expr using _clean_numerical_artifacts (ported to work with SymEngine/SymPy).
Expand the cleaned expr.
Use logic similar to your existing _monomial_key to iterate through terms of the expanded SymEngine expression.
For each term, extract the exponent tuple (key) and the numerical coefficient (value, ensuring np.complex128).
Aggregate coefficients for identical keys in a defaultdict.
Return cls(variables, aggregated_coeffs).
Phase 2: Numba Acceleration (Focus on dict_core.py)
Data Conversion Helpers:
_dict_to_arrays(coeffs: Dict[Tuple[int, ...], np.complex128], n_vars: int): Convert coeffs dict to keys_array: np.ndarray[(N, n_vars), np.int_], coeffs_array: np.ndarray[(N,), np.complex128].
_arrays_to_dict(keys_array: np.ndarray, coeffs_array: np.ndarray): Convert arrays back to Dict[Tuple[int, ...], np.complex128]. Needs to handle potential duplicate keys generated by Numba operations (e.g., by summing coefficients for identical keys). Sorting and grouping can help here.
Numba Multiplication (@numba.njit):
Create _numba_mul(keys1, coeffs1, keys2, coeffs2, n_vars) function.
Input: NumPy arrays from _dict_to_arrays.
Logic: Implement the nested loops for polynomial multiplication operating purely on the input arrays. Generate potentially large intermediate arrays of new keys and coefficients.
Output: new_keys_array, new_coeffs_array. (Aggregation of duplicates might happen here or in _arrays_to_dict).
Modify DictPolynomial.__mul__: Convert inputs using _dict_to_arrays, call _numba_mul, convert result using _arrays_to_dict.
Numba Differentiation (@numba.njit):
Create _numba_derivative(keys, coeffs, n_vars, var_index).
Input: NumPy arrays.
Logic: Array-based implementation of the differentiation rule.
Output: new_keys_array, new_coeffs_array.
Modify DictPolynomial.derivative: Use _dict_to_arrays, _numba_derivative, _arrays_to_dict.
Numba Poisson Bracket (@numba.njit):
Create _numba_poisson(keys_F, coeffs_F, keys_G, coeffs_G, n_vars, n_dof).
Input: NumPy arrays for F and G.
Logic:
Calculate gradients (calling _numba_derivative or implementing inline). This yields 4 sets of arrays (dF/dq, dF/dp, dG/dq, dG/dp).
Perform multiplications using _numba_mul (e.g., dF/dq_i * dG/dp_i).
Perform additions/subtractions (implement array-based term merging/aggregation).
Output: result_keys_array, result_coeffs_array.
Modify DictPolynomial.poisson: Use _dict_to_arrays, _numba_poisson, _arrays_to_dict.
Phase 3: Refactor Application Code (factory.py, lie.py)
Update Imports: Change imports from core to dict_core. Replace Polynomial with DictPolynomial.
factory.py:
hamiltonian: Build the SymEngine expression as before, then convert the final H_phys to DictPolynomial using DictPolynomial.from_symengine.
Coordinate Transformations (physical_to_real_normal, etc.):
Keep using SymEngine.subs for the core substitution logic on SymEngine objects.
Perform numerical cleaning (_clean_numerical_artifacts) on the resulting SymEngine expression.
Convert the final SymEngine expression of each function to DictPolynomial using DictPolynomial.from_symengine.
lie.py:
Replace all uses of the old Polynomial class and its methods with DictPolynomial.
_get_homogeneous_terms: Use DictPolynomial.get_homogeneous_part.
_select_monomials_for_elimination: Iterate through terms of the input DictPolynomial, check the condition key[0] != key[self.n_dof], collect terms for the output DictPolynomial.
_solve_homological_equation: Iterate input DictPolynomial. Calculate denominator (may still need symbolic _dot_product if eta_vector is symbolic, otherwise pre-calculate). Compute new coefficient. Build output coeffs dict.
_apply_lie_transform: The loop structure remains. Replace all arithmetic and Poisson bracket calls with DictPolynomial methods (which now use Numba). Remove reliance on SymEngine-specific methods like expansion. Caching (lru_cache) on memoized_poisson might need removal or careful adaptation if Numba is used heavily within poisson.
Update coefficient extraction/formatting functions to work with DictPolynomial.coeffs.
Phase 4: Testing and Profiling
Unit Tests: Create test_dict_core.py. Test all DictPolynomial methods, especially arithmetic and Poisson brackets. Compare results against SymEngine for small, known cases. Test Numba functions with sample array inputs if feasible.
Integration Tests: Run the full lie.py calculation for a low max_degree (e.g., 3 or 4). Compare the final numerical coefficients generated by the refactored code against the results from your original SymEngine-based code. Use np.allclose for comparisons.
Profiling: Use cProfile or line_profiler on the main calculation (compute_center_manifold). Verify that the time spent inside DictPolynomial arithmetic/Poisson methods is significantly reduced and that Numba functions are executing as expected.
This structured approach allows for incremental changes, testing at each phase, and focuses optimization efforts on the most critical parts identified by profiling.
