import symengine as se
import numpy as np

from .core import Polynomial
from system.libration import LibrationPoint


def lie_transform(point: LibrationPoint, H_init: Polynomial, max_degree: int) -> tuple[Polynomial, Polynomial]:
    """
    Bring *H_init* to the Jorba-Masdemont partial normal form up to
    *max_degree* using a Lie-series expansion.

    Parameters
    ----------
    point : LibrationPoint
        The LibrationPoint object (needed for linear modes)
    H_init : Polynomial
        Hamiltonian already expressed in complex canonical variables
        (q1,q2,q3,p1,p2,p3), with a working ``build_by_degree`` helper.
    max_degree : int
        Highest total degree to normalise and keep.

    Returns
    -------
    tuple[Polynomial, Polynomial]
        (H_normalized, G_total) where H_normalized is the transformed
        Hamiltonian and G_total is the accumulated generating function.
    """
    H_transformed = H_init.copy()
    G_total = Polynomial(H_init.variables, se.Integer(0))
    lambda1, omega1, omega2 = point.linear_modes()

    eta_vector = [se.sympify(lambda1), se.I*se.sympify(omega1), se.I*se.sympify(omega2)]

    # H_2 is the homogeneous part of H_init of degree 2
    H_2 = _get_homogeneous_terms(H_init, 2)

    for n in range(3, max_degree + 1):
        print(f"Normalizing order {n}...") # Progress indicator

        # Step 6: Extract homogeneous terms of degree n
        H_n_current = _get_homogeneous_terms(H_transformed, n)
        if H_n_current.total_degree() == 0: # If H_n is zero, nothing to eliminate
            print(f"Order {n} is zero, skipping normalization for this order.")
            continue

        # Step 7: Select monomials for elimination
        H_n_to_eliminate = select_monomials_for_elimination(H_n_current)

        # If there are no terms to eliminate at this order, skip
        if H_n_to_eliminate.total_degree() == 0:
            print(f"No terms to eliminate at order {n}.")
            continue

        # Step 8: Solve homological equation to find G_n
        G_n = solve_homological_equation(H_n_to_eliminate, H_2, eta_vector, H_init.variables)

        # Step 9: Apply Lie series transform generated by G_n to H_transformed
        H_transformed = apply_lie_transform(H_transformed, G_n, max_degree)

        # Step 10: Add G_n to total generating function
        G_total = G_total + G_n
        # Truncate G_total to max_degree? The paper doesn't explicitly state,
        # but keeping it truncated might be more manageable. Let's truncate.
        G_total = G_total.truncate(max_degree)


    # After the loop, H_transformed is the normalized Hamiltonian up to max_degree
    # and G_total is the sum of generators G_3 + ... + G_max_degree
    return H_transformed, G_total


def _get_homogeneous_terms(H: Polynomial, n: int) -> Polynomial:
    """
    Extracts the homogeneous polynomial of degree n from Hamiltonian H.

    Parameters
    ----------
    H : Polynomial
        The input polynomial.
    n : int
        The desired degree.

    Returns
    -------
    Polynomial
        The homogeneous part of H of degree n.
    """
    # build_by_degree returns a dict {degree: [monomials]}
    monomials_by_degree = H.build_by_degree()

    # Get the list of monomials for the specified degree n
    # If degree n is not present, it will return an empty list from defaultdict
    homogeneous_monomials = monomials_by_degree.get(n, [])

    # Construct a new Polynomial from these monomials
    # Pass the variables from the original polynomial
    return Polynomial.from_monomials(H.variables, homogeneous_monomials)


def _select_monomials_for_elimination(H_n_current: Polynomial) -> Polynomial:
    """
    Selects monomials from H_n_current for elimination based on the partial
    normalization condition (kq[0] != kp[0]).

    Parameters
    ----------
    H_n_current : Polynomial
        The homogeneous polynomial of degree n.

    Returns
    -------
    Polynomial
        A polynomial containing only the terms from H_n_current to be eliminated.
    """
    monomials_to_eliminate = []

    # Iterate through all monomials in the homogeneous polynomial
    for coeff, monomial in H_n_current.iter_terms():
        # Check the condition for partial normalization: kq[0] != kp[0]
        # kq[0] is the exponent of q1, kp[0] is the exponent of p1
        if monomial.kq[0] != monomial.kp[0]:
            monomials_to_eliminate.append(monomial)

    # Construct a new Polynomial from the selected monomials
    return Polynomial.from_monomials(H_n_current.variables, monomials_to_eliminate)
